<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>リアルタイムデータ時系列グラフ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            padding: 20px;
        }
        .client-card {
            border: 1px solid #ddd;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 16px;
            width: 600px;
        }
        .client-card h2 {
            font-size: 18px;
            margin: 0 0 10px;
        }
        canvas {
            max-width: 100%;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">Mediapipe Monitor</h1>
    <div class="container" id="client_container"></div>

    <!-- Chart.jsを読み込み -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>
        const protocol = window.location.protocol === "https:" ? "wss" : "ws";
        const host = window.location.host;

        // WebSocket接続の確立
        const socket = new WebSocket(`${protocol}://${host}/ws-monitor`);

        // 時系列データを保存するためのオブジェクト
        const clientDataHistory = {}; // { userId: { labels: [], datasets: {} } }
        let charts = {}; // クライアントごとにChartインスタンスを保持

        // WebSocketが開いたときの処理
        socket.onopen = function () {
            console.log("WebSocket接続が確立しました。");
        };

        // データ受信時の処理
        socket.onmessage = function (event) {
            try {
                // 受信データの解析
                const responseData = JSON.parse(event.data);
                console.log(responseData);
                Object.keys(responseData).forEach(parent => {
                    // 必須フィールドの存在確認
                    if (!responseData[parent] || !responseData[parent].data || !responseData[parent].user_id) {
                        console.warn("WebSocket: 必須フィールドが不足しています。無効なデータ:", responseData[parent]);
                        return;
                    }

                    const { data: samples, user_id } = responseData[parent];

                    // user_idを利用して親（ユーザー）ごとのデータにアクセス
                    if (!clientDataHistory[user_id]) {
                        // ユーザーごとの履歴データが存在しない場合、新規作成
                        clientDataHistory[user_id] = {
                            user_id: user_id, // ユーザーIDを追跡
                            labels: [], // このユーザーの時系列データ（ラベル）
                            datasets: {} // このユーザー内のデータセット
                        };
                    }

                    // ユーザー情報を参照（例：IDと受信したデータの確認）
                    console.log(`User ID: ${user_id} のデータを処理しています。`);

                    // データ処理ロジック
                    samples.forEach(sample => {
                        const { sub_timestamp, data } = sample;

                        // 各データ項目を処理
                        data.forEach(({ name, value, unit }) => {
                            const datasetKey = `${name} (${unit})`; // データキー例: "heart_rate (bpm)"

                            if (!clientDataHistory[user_id].datasets[datasetKey]) {
                                clientDataHistory[user_id].datasets[datasetKey] = [];
                            }

                            // データを追加
                            clientDataHistory[user_id].datasets[datasetKey].push(value);

                            // 最大保持件数を超えた場合、古いデータを削除
                            if (clientDataHistory[user_id].datasets[datasetKey].length > 200) {
                                clientDataHistory[user_id].datasets[datasetKey].shift();
                            }
                        });

                        // `sub_timestamp` をラベルに追加
                        clientDataHistory[user_id].labels.push(new Date(sub_timestamp).toLocaleTimeString());

                        // ラベルが最大件数を超える場合の処理
                        if (clientDataHistory[user_id].labels.length > 200) {
                            clientDataHistory[user_id].labels.shift();
                        }
                    });

                    // チャートを更新
                    if (charts[user_id]) {
                        updateChartData(charts[user_id], clientDataHistory[user_id]);
                    } else {
                        drawChart(user_id, clientDataHistory[user_id]);
                    }
                });
            } catch (e) {
                console.error("データ解析エラー:", e);
            }
        };

        // グラフを描画する関数（初期化）
        function drawChart(userId, initialData) {
            const container = document.getElementById("client_container");

            // クライアントごとのカード作成
            let card = document.getElementById(`card_${userId}`);
            if (!card) {
                card = document.createElement("div");
                card.className = "client-card";
                card.id = `card_${userId}`;
                container.appendChild(card);

                const title = document.createElement("h2");
                title.textContent = `ユーザーID: ${userId}`;
                card.appendChild(title);

                const canvas = document.createElement("canvas");
                canvas.id = `chart_${userId}`;
                card.appendChild(canvas);
            }

            // データセットを生成
            const datasets = Object.entries(initialData.datasets).map(([key, values]) => ({
                label: key, // 例: "heart_rate (bpm)"
                data: values, // 初期値リスト
                fill: false,
                borderColor: randomColor(),
                tension: 0.1
            }));

            const ctx = document.getElementById(`chart_${userId}`).getContext('2d');
            charts[userId] = new Chart(ctx, {
                type: 'line', // 折れ線グラフ
                data: {
                    labels: initialData.labels, // 時系列のラベル
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    animation: false, // アニメーションを無効化
                    scales: {
                        x: {
                            title: { display: true, text: "時刻" }
                        },
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: "値" }
                        }
                    }
                }
            });
        }


        function updateChartData(chart, updatedData) {
            const { labels: newLabels, datasets: newDatasets } = updatedData;

            // 現在のラベルとデータセット
            const currentLabels = chart.data.labels || [];
            const currentDatasets = chart.data.datasets || [];

            // 現在のラベルを効率的な検索のためにSet化
            const existingLabels = new Set(currentLabels);

            // 新しいラベルとデータを時系列順で処理
            newLabels.forEach((newLabel, labelIndex) => {
                if (!existingLabels.has(newLabel)) {
                    // 新しいラベルを追加
                    currentLabels.push(newLabel);

                    Object.entries(newDatasets).forEach(([key, newValues]) => {
                        // データセットの取得/作成
                        let dataset = currentDatasets.find(ds => ds.label === key);
                        if (!dataset) {
                            // データセットが存在しない場合、初期化
                            dataset = {
                                label: key,
                                data: Array(currentLabels.length - 1).fill(null), // ラベルに合わせる
                                fill: false,
                                borderColor: randomColor(),
                                tension: 0.1
                            };
                            currentDatasets.push(dataset);
                        }

                        // データセットに対応する新しいデータを追加
                        dataset.data.push(newValues[labelIndex] || null);
                    });
                }
            });

            // ラベルが最大件数を超える場合、古いものを削除
            if (currentLabels.length > 200) {
                currentLabels.shift();
                currentDatasets.forEach(dataset => {
                    dataset.data.shift();
                });
            }

            // グラフを更新
            chart.update();
        }



        // ランダムな色を生成する関数
        function randomColor() {
            const r = Math.floor(Math.random() * 255);
            const g = Math.floor(Math.random() * 255);
            const b = Math.floor(Math.random() * 255);
            return `rgba(${r}, ${g}, ${b}, 0.7)`;
        }

        // WebSocketが閉じたときの処理
        socket.onclose = function () {
            console.warn("WebSocket接続が切断されました。");
            alert("サーバーとの接続が切断されました。ページを再読み込みしてください。");
        };

        // エラーが発生した場合の処理
        socket.onerror = function (error) {
            console.error("WebSocketエラー:", error);
        };
    </script>
</body>
</html>